<?  $Loader->Parent_Class('/Object');    abstract class C_Builder_Compiler_CPP_Base_Instance extends C_Object  {    Static $ShortName='CPP';    Var $DirVersion='Vx';  //Var $Path='Path/Of/Compiler';      Abstract Function GetCompilerIdHash();      Function _Prepare($Exec)    {    }        Function CreateOutPath($Outer)    {      $I=$Outer->GetModuleInstance();      $Add=$this->DirVersion.($Outer->IsDebug()? '_Debug':'').($Outer->IsStatic()? '_Static':'');    //$Add=Static::$ShortName.'_'.$this->DirVersion.'_'.($Outer->IsDebug()? '_Debug':'').($Outer->IsStatic()? '_Static':'');      $Key=$this->GetCompilerIdHash(); // TODO: Predefines      $Res=$I->EnumCache->AllocFull($Key, $Add, ['Pad'=>1, 'NoZero'=>true, 'Split'=>'_']).'/';      return $Res;    }        Function GetPchFile    ($Name) { return $Name.'.PreCompledHeader' ; }    Function GetObjFile    ($Name) { return $Name.'.Object'           ; }    Function GetExeFile    ($Name) { return $Name.'.Executable'       ; }    Function GetDllFile    ($Name, $bDebug=false) { return $Name.($bDebug? '.Debug.Dynamic'          :'.Dynamic'          ); }    Function GetDllLibFile ($Name, $bDebug=false) { return $Name.($bDebug? '.Debug.Dynamic.Liberary' :'.Dynamic.Liberary' ); }    Function GetLibFile    ($Name, $bDebug=false) { return $Name.($bDebug? '.Debug.Liberary'         :'.Liberary'         ); }        Function DefineDLLExport () { return 'Export Of DLL'; }    Function DefineDLLImport () { return 'Import Of DLL'; }  //Function DefineDLLProxy  () { return 'Proxy  Of DLL'; }      Function DetectUsingPath($Path) {}        Protected Function _CompileItem (Array $Args) {}    Protected Function _Compile     (Array $Args) {}    Protected Function _BuildExe    (Array $Args) {}    Protected Function _BuildDll    (Array $Args) {}    Protected Function _BuildRc     (Array $Args) {}    Protected Function _BuildResX   (Array $Args) {}        Function PrepareExec($Exec){ }        Final Function Compile(Array $Args)    {      $Objects  =$Args['Objects'  ]??[];      $Libs     =$Args['Libs'     ]??[];      $Items    =$Args['Items'    ];      $Using    =$Args['Using'    ]??[];      $DepUsing =$Args['DepUsing' ]??false;            $FileDepends=[];     #ForEach($Objects As $Item) $FileDepends[$Item->Object_Id]=$Item;      ForEach($Libs    As $Item) $FileDepends[$Item->Object_Id]=$Item;      if($DepUsing)      ForEach($Using   As $Item) $Item->UseForObj($FileDepends);      if($FileDepends)        ForEach($Items As $Item)        {          $Item['ObjAsset']->AddFileDepends($FileDepends);        //TODO: $Item['ObjAsset']->AddFileDepends($Item['SrcAsset']->GetFileDepends()); // Dll and Libs        }            $Args['Params']=$this->_CompileParams($Args);      $Res=[];      $this->_CompileSplit($Res, $Args);     #$Deb=$this->Loader->Get_Singleton('/Debug/Manager')->Get('Split.log');     #  ForEach($Args['Items'] As $j=>$Item)     #    $Deb->Writeln('>'.$j.' '.$Item['ObjAsset']->GetLocalPath());     #$Deb->Writeln('>>>');     #ForEach($Res As $i=>$Entry)     #  ForEach($Entry['Items'] As $j=>$Item)     #    $Deb->Writeln('>'.$i.'.'.$j.' '.$Item['ObjAsset']->GetLocalPath());     #$Deb->Writeln('---');    //$Deb->Debug($Res, 1);            ForEach($Res As $_Args)        $this->Compile_($_Args);    }        Protected Function _CompileParams(Array $Args)    {      $Params=$this->CreateParams();      return $Params;    }        Protected Function _CompileSplit(Array &$Res, Array $Args)    {      $Items=$Args['Items'];      if(false)      {        echo '>>>>>>>>>',"\n";        ForEach($Items As $Item)          echo $Item['OutPath'][1],"\n";        echo '<<<<<<<<<',"\n";      }      $c=count($Items);      if(!$c) return;      if($c>2 && $this->Compile_CanGroupByDir($Args))      {        $Params   =$Args['Params'   ];        $Groups=[];        ForEach($Items As $Item)        {          $ObjAsset =$Item['ObjAsset' ];          $GPath=$ObjAsset->GetDirFullPath();          if(!IsSet($Groups[$GPath]))            $Groups[$GPath]=[$Item];          else            $Groups[$GPath][]=$Item;        }        ForEach($Groups As $GPath=>$GItems)        {          $First=$GItems[0];          $_Args=$Args;          UnSet($_Args['Items'  ]); // Fix of big bug          $_Args['Dir'     ]=$GPath; //$ObjAsset->GetDirFullPath();          $_Args['Items'   ]=$GItems;          $_Args['Params'  ]=clone $Params;          $_Args['Exec'    ]=$First['Exec'     ];          $_Args['OutPath' ]=$First['OutPath'  ];          $_Args['First'   ]=$First;          $Res[]=$_Args;          UnSet($GItems); // Fix of big bug        }      }      else        $Res[]=$Args;    }        Function Compile_(Array $Args)    {                if(false)      {        echo '>>>>>>>>>',"\n";        echo 'Dir: ',$Args['Dir'],"\n";        ForEach($Args['Items'] As $Item)          echo $Item['OutPath'][1],'     -> ',$Item['ObjAsset']->GetLocalPath(),"\n";        echo '<<<<<<<<<',"\n";      }      if(IsSet($Args['Dir']))        $this->CompileDir_($Args);      else        $this->CompileItems_($Args);    }          Protected Function CompileItems_(Array $Args)    {      $Defines   = $Args['Defines'   ];      $Includes  = $Args['Includes'  ];      $Using     = $Args['Using'     ];      $UsingPath = $Args['UsingPath' ];      $Items     = $Args['Items'     ];      $Params    = $Args['Params'    ];            ForEach($Items As $k=>$Item)      {        $Items[$k]['Params']=clone $Params; // Fix of big bug        $SrcAsset =$Item['SrcAsset' ];        $ObjAsset =$Item['ObjAsset' ];        $Exec     =$Item['Exec'     ];        $this->PrepareExec($Exec);        $Exec->Descr('Compile ',$SrcAsset->GetLocalPathNick());                $Exec->CheckObjects($Includes);       #$Exec->CheckObjects($UsingPath); // TODO:        $Exec->CheckObjects($Using);        $Exec->CheckFile($SrcAsset);        $Exec->MkDir($ObjAsset);                UnSet($SrcAsset );        UnSet($ObjAsset );        UnSet($Exec     );        UnSet($Item);      }      $Args['Items']=$Items; // Fix of big bug          $this->_CompileItems($Args);      ForEach($Items As $Item)      {        $ObjAsset =$Item['ObjAsset' ];        $Exec     =$Item['Exec'     ];        $OutPath  =$Item['OutPath'  ];              $Exec->CheckResultFile($ObjAsset);        $Exec->SaveCallTo($OutPath[0].'Task/Obj/'.$OutPath[1]);        $Exec->Finish();        UnSet($ObjAsset );        UnSet($Exec     );        UnSet($Path     );      }    }        Protected Function _CompileItems(Array $Args)    {      ForEach($Args['Items']As $Item)        $this->_CompileItem($Item);    }        Protected Function CompileDir_(Array $Args)    {      $Defines  =$Args['Defines'  ];      $Includes =$Args['Includes' ];      $Items    =$Args['Items'    ];      $Exec     =$Args['Exec'     ];      $OutPath  =$Args['OutPath'  ];      if(false)      {        echo '>>>>>>>>>',"\n";        echo 'Dir: ',$Args['Dir'],"\n";        $Item=$Args['First'];        echo $Item['OutPath'][1],'     -> ',$Item['ObjAsset']->GetLocalPath(),"\n";        ForEach($Args['Items'] As $Item)          echo $Item['OutPath'][1],'     -> ',$Item['ObjAsset']->GetLocalPath(),"\n";        echo '<<<<<<<<<',"\n";      }      $this->PrepareExec($Exec);      $Exec->CheckObjects($Includes);      $Exec->MkDir($Args['First']['ObjAsset']);              ForEach($Items As $Item)      {        $SrcAsset =$Item['SrcAsset' ];        $Exec->Descr('Compile ',$SrcAsset->GetLocalPathNick());                $Exec->CheckFile($SrcAsset);                UnSet($SrcAsset );      }           $this->_CompileDir($Args);      ForEach($Items As $Item)      {        $ObjAsset =$Item['ObjAsset' ];        $ExExec   =$Item['Exec'     ];               if($ExExec->Object_Id!==$Exec->Object_Id)         $ExExec->Refuse();              $Exec->CheckResultFile($ObjAsset);                UnSet($ExExec   );        UnSet($ObjAsset );      }      $Exec->SaveCallTo($OutPath[0].'Task/Obj/'.$OutPath[1]);      $Exec->Finish();    }        Protected Function _CompileDir($Args) { FAbstract(); }        Static Function AgregateLibs($Libs)    {      $Libs=C_Builder_Asset_FS_PathBase::_GetFileDependsR($Libs);      $Libs=C_Builder_Asset_FS_PathBase::_Filter($Libs, 'Cpp/Lib');      Return $Libs;     #$Res=[];     #Static::_AgregateLibs($Res, $Libs);     #return $Res;    }        Static Function _AgregateLibs(&$Res, $Libs)    {      ForEach($Libs As $Lib)        If(!IsSet($Res[$Lib->Object_Id]))        {          Static::_AgregateLibs($Res, $Lib->GetFileDepends('Cpp/Lib'));          $Res[$Lib->Object_Id]=$Lib;        }    }    Final Function BuildRc(Array $Args)    {      $Exec      =$Args['Exec'     ];      $RcAsset   =$Args['RcAsset'  ];      $ResAsset  =$Args['ResAsset' ];      $OutPath   =$Args['OutPath'  ];      $Exec->Descr('Build ',$ResAsset->GetLocalPathNick());      $Exec->CheckFile  ($RcAsset );      $Exec->MkDir($ResAsset);            //rc /l"0x0409" /nologo /fo"Release\app.res" app.rc            $this->_BuildRc($Args);       $Exec->CheckResultFile($ResAsset);            $Exec->SaveCallTo($OutPath[0].'Task/Rc/'.$OutPath[1]);      $Exec->Finish();    }        Final Function BuildResX(Array $Args)    {      $Exec      =$Args['Exec'      ];      $Using     =$Args['Using'     ];      $ResXAsset =$Args['ResXAsset' ];      $Resources =$Args['Resources' ];      $OutPath   =$Args['OutPath'   ];            //resgen /useSourcePath /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Core.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Data.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Drawing.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Windows.Forms.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Xml.dll" /compile FogTunerControl.resX,Release\FogTuner.FogTunerControl.resources      $Exec->Descr('Build ',$Resources->GetLocalPathNick());      $Exec->CheckFile  ($ResXAsset );      $Exec->CheckFiles ($Using     );      $Exec->MkDir($Resources);          $this->_BuildResX($Args);      $Exec->CheckResultFile($Resources);            $Exec->SaveCallTo($OutPath[0].'Task/ResX/'.$OutPath[1]);      $Exec->Finish();    }      //$Args['Exec'     ]=$this->Create_Exec();  //$Args['Objects'  ]=$this->RemoveAssets('Cpp/Obj');  //$Args['Libs'     ]=$this->RemoveAssetsR('Cpp/Lib');  //$Args['ExeAsset' ]=$this->CreateAsset('Bin/Exe', ['Path'=>$Compiler->GetExeFile($ExeName)]);    Final Function BuildExe(Array $Args)    {      $Exec      =$Args['Exec'      ];      $Objects   =$Args['Objects'   ];      $Libs      =$Args['Libs'      ];      $Using     =$Args['Using'     ];      $ExeAsset  =$Args['ExeAsset'  ];      $OutPath   =$Args['OutPath'   ];      $ResAsset  =$Args['ResAsset'  ]??[];      $Resources =$Args['Resources' ]??[];          //$this->Debug(array_column($Libs, 'LocalPath'));      $Libs=Static::AgregateLibs($Libs); $Args['Libs']=$Libs;    //$this->Debug(array_column($Libs, 'LocalPath'));            ForEach($Objects As $Item) $ExeAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));      ForEach($Libs    As $Item) $ExeAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));      ForEach($Using   As $Item) $Item->UseForExe($ExeAsset);            $this->PrepareExec($Exec);            $Exec->Descr('Build ',$ExeAsset->GetLocalPathNick());      $Exec->CheckFiles($Objects   );      $Exec->CheckFiles($Libs      );      $Exec->CheckFiles($Using     );      $Exec->CheckFiles($ResAsset  );      $Exec->CheckFiles($Resources );      $Exec->MkDir($ExeAsset);            $this->_BuildExe($Args);      // TODO: Copy depends dlls      $Exec->CheckResultFile($ExeAsset);      $Exec->SaveCallTo($OutPath[0].'Task/Exe/'.$OutPath[1]);      $Exec->Finish();    }  //$Args['Exec'     ]=$this->Create_Exec();  //$Args['Objects'  ]=$this->RemoveAssets('Cpp/Obj');  //$Args['Libs'     ]=$this->RemoveAssetsR('Cpp/Lib');  //$Args['DllAsset' ]=$this->CreateAsset('Bin/Dll', ['Path'=>$Compiler->GetDllFile    ($Name)]);  //$Args['LibAsset' ]=$this->CreateAsset('Bin/Lib', ['Path'=>$Compiler->GetDllLibFile ($Name)]);    Final Function BuildDll(Array $Args)    {      $Exec      =$Args['Exec'      ];      $Objects   =$Args['Objects'   ];      $Libs      =$Args['Libs'      ];      $Using     =$Args['Using'     ];      $DllAsset  =$Args['DllAsset'  ];      $LibAsset  =$Args['LibAsset'  ]??false;      $OutPath   =$Args['OutPath'   ];      $ResAsset  =$Args['ResAsset'  ]??[];      $Resources =$Args['Resources' ]??[];            $Libs=Static::AgregateLibs($Libs); $Args['Libs']=$Libs;            ForEach($Objects As $Item) $DllAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));      ForEach($Libs    As $Item) $DllAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));      if($LibAsset)              $LibAsset->AddFileDepends($DllAsset);      ForEach($Using   As $Item) $Item->UseForDll($DllAsset);            $this->PrepareExec($Exec);            $Exec->Descr('Build ',$DllAsset->GetLocalPathNick());      $Exec->CheckFiles($Objects   );      $Exec->CheckFiles($Libs      );      $Exec->CheckFiles($Using     );      $Exec->CheckFiles($ResAsset  );      $Exec->CheckFiles($Resources );      $Exec->MkDir($DllAsset);      if($LibAsset)        $Exec->MkDir($LibAsset);            $this->_BuildDll($Args);            $Exec->CheckResultFile($DllAsset);      if($LibAsset)        $Exec->CheckResultFile($LibAsset);            $Exec->SaveCallTo($OutPath[0].'Task/Dll/'.$OutPath[1]);      $Exec->Finish();    }  //$Args['Exec'     ]=$this->Create_Exec();  //$Args['Objects'  ]=$this->RemoveAssets('Cpp/Obj');  //$Args['Libs'     ]=$this->RemoveAssetsR('Cpp/Lib');  //$Args['LibAsset' ]=$this->CreateAsset('Bin/Lib', ['Path'=>$Compiler->GetLibFile ($Name)]);    Final Function BuildLib(Array $Args)    {      $Exec     =$Args['Exec'     ];      $Objects  =$Args['Objects'  ];      $Libs     =$Args['Libs'     ];      $Using    =$Args['Using'    ];      $LibAsset =$Args['LibAsset' ];      $OutPath  =$Args['OutPath'  ];          //ForEach($Objects As $Item) $LibAsset->AddFileDepends($Item); //TODO: Add 'Bin/Dll' and 'Cpp/Lib'      ForEach($Libs    As $Item) $LibAsset->AddFileDepends($Item); //'Bin/Dll'      ForEach($Using   As $Item) $Item->UseForLib($LibAsset);            $this->PrepareExec($Exec);            $Exec->Descr('MakeLib ',$LibAsset->GetLocalPathNick());            $Exec->CheckFiles($Objects );    //$Exec->CheckFiles($Libs    );      $Exec->MkDir($LibAsset);       $this->_BuildLib($Args);      $Exec->CheckResultFile($LibAsset);      $Exec->SaveCallTo($OutPath[0].'Task/Lib/'.$OutPath[1]);      $Exec->Finish();    }    Function CreateParams() { return $this->Create_Object('/Builder/Task/Params'); }  }?>