<?
  $Loader->Parent_Class('/Object');
  
  abstract class C_Builder_Compiler_CPP_Base_Instance extends C_Object
  {
    Static $ShortName='CPP';
    Var $DirVersion='Vx';
    Var $Manager=null;
  //Var $Path='Path/Of/Compiler';
  
    Abstract Function GetCompilerIdHash();
    Abstract Function CMake_GetGenerator();
    Abstract Function IsCompiler($Name);
    Abstract Function CompareVersion($Name);
    
    Function _Init(Array $Args)
    {
      Parent::_Init($Args);
      $this->Manager=$Args['Manager'];
    }
  
    Function _Prepare($Exec)
    {
    }
    
    Function CreateOutPath($Outer)
    {
      $I=$Outer->GetModuleInstance();
      $Add=$this->DirVersion.($Outer->IsDebug()? '_Debug':'').($Outer->IsStatic()? '_Static':'');
    //$Add=Static::$ShortName.'_'.$this->DirVersion.'_'.($Outer->IsDebug()? '_Debug':'').($Outer->IsStatic()? '_Static':'');
      $Key=$this->GetCompilerIdHash(); // TODO: Predefines
      $Res=$I->EnumCache->AllocFull($Key, $Add, ['Pad'=>1, 'NoZero'=>true, 'Split'=>'_']).'/';
      return $Res;
    }
    
    Abstract Function GetPchFile    ($Name); // { return $Name.'.PreCompledHeader' ; }
    Abstract Function GetObjFile    ($Name); // { return $Name.'.Object'           ; }
    Abstract Function GetExeFile    ($Name); // { return $Name.'.Executable'       ; }
    Abstract Function GetDllFile    ($Name); // { return $Name.'.Dynamic'          ; }
    Abstract Function GetDllLibFile ($Name); // { return $Name.'.Dynamic.Liberary' ; }
    Abstract Function GetLibFile    ($Name); // { return $Name.'.Liberary'         ; }

    Abstract Function DefineDLLExport (); // { return 'Export Of DLL'; }
    Abstract Function DefineDLLImport (); // { return 'Import Of DLL'; }
  //Abstract Function DefineDLLProxy  (); // { return 'Proxy  Of DLL'; }
  
    Function DetectUsingPath($Path) {}
    
    Abstract Protected Function _BuildExe    (Array $Args); // {}
    Abstract Protected Function _BuildDll    (Array $Args); // {}
    Abstract Protected Function _BuildRc     (Array $Args); // {}
    Abstract Protected Function _BuildResX   (Array $Args); // {}
    
    Function PrepareExec($Exec){ }
    
    Final Function Compile(Array $Args)
    {
      $Task=$this->CreateTaskCompile($Args);
      $Task->Compile();
    }
    
    Abstract Protected Function CreateTaskCompile(Array $Args);
    
    Static Function AgregateLibs($Libs)
    {
      $Libs=C_Builder_Asset_FS_PathBase::_GetFileDependsR($Libs);
      $Libs=C_Builder_Asset_FS_PathBase::_Filter($Libs, 'Cpp/Lib');
      Return $Libs;
     #$Res=[];
     #Static::_AgregateLibs($Res, $Libs);
     #return $Res;
    }
    
    Static Function _AgregateLibs(&$Res, $Libs)
    {
      ForEach($Libs As $Lib)
        If(!IsSet($Res[$Lib->Object_Id]))
        {
          Static::_AgregateLibs($Res, $Lib->GetFileDepends('Cpp/Lib'));
          $Res[$Lib->Object_Id]=$Lib;
        }
    }

    Final Function BuildRc(Array $Args)
    {
      $Exec      =$Args['Exec'     ];
      $RcAsset   =$Args['RcAsset'  ];
      $ResAsset  =$Args['ResAsset' ];
      $Includes  =$Args['Includes' ];

      $Exec->Descr('Build ',$ResAsset->GetLocalPathNick());
      $Exec->CheckInputs($Includes); // TODO: Check depends for resources
      $Exec->CheckFile  ($RcAsset );
      $Exec->MkDir($ResAsset);
      
      //rc /l"0x0409" /nologo /fo"Release\app.res" app.rc
      
      $this->_BuildRc($Args);
 
      $Exec->CheckResultFile($ResAsset);
      
      $Exec->SaveCallTo();
      $Exec->Finish();
    }
    
    Final Function BuildResX(Array $Args)
    {
      $Exec      =$Args['Exec'      ];
      $Using     =$Args['Using'     ];
      $ResXAsset =$Args['ResXAsset' ];
      $Resources =$Args['Resources' ];
      
      //resgen /useSourcePath /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Core.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Data.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Drawing.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Windows.Forms.dll" /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Xml.dll" /compile FogTunerControl.resX,Release\FogTuner.FogTunerControl.resources
      $Exec->Descr('Build ',$Resources->GetLocalPathNick());
      $Exec->CheckFile  ($ResXAsset );
      $Exec->CheckFiles ($Using     );
      $Exec->MkDir($Resources);
    
      $this->_BuildResX($Args);

      $Exec->CheckResultFile($Resources);
      
      $Exec->SaveCallTo();
      $Exec->Finish();
    }
    
  //$Args['Exec'     ]=$this->Create_Exec();
  //$Args['Objects'  ]=$this->ExtractAssets('Cpp/Obj');
  //$Args['Libs'     ]=$this->ExtractAssetsR('Cpp/Lib');
  //$Args['ExeAsset' ]=$this->CreateAsset('Bin/Exe', ['Path'=>$Compiler->GetExeFile($ExeName)]);
    Final Function BuildExe(Array $Args)
    {
      $Exec      =$Args['Exec'      ];
      $Objects   =$Args['Objects'   ];
      $Libs      =$Args['Libs'      ];
      $Using     =$Args['Using'     ];
      $ExeAsset  =$Args['ExeAsset'  ];
      $ResAsset  =$Args['ResAsset'  ]??[];
      $Resources =$Args['Resources' ]??[];
      $Manifests =$Args['Manifests' ]??[];
      
    //$this->Debug(array_column($Libs, 'LocalPath'));
      $Libs=Static::AgregateLibs($Libs); $Args['Libs']=$Libs;
    //$this->Debug(array_column($Libs, 'LocalPath'));
      
      ForEach($Objects As $Item) $ExeAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));
      ForEach($Libs    As $Item) $ExeAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));
      ForEach($Using   As $Item) $Item->UseForExe($ExeAsset);
      
      $this->PrepareExec($Exec);
      
      $Exec->Descr('Build ',$ExeAsset->GetLocalPathNick());
      $Exec->CheckFiles($Objects   );
      $Exec->CheckFiles($Libs      );
      $Exec->CheckFiles($Using     );
      $Exec->CheckFiles($ResAsset  );
      $Exec->CheckFiles($Resources );
      $Exec->CheckFiles($Manifests );
      $Exec->MkDir($ExeAsset);
      
      $this->_BuildExe($Args);
      // TODO: Copy depends dlls
      $Exec->CheckResultFile($ExeAsset);

      $Exec->SaveCallTo();
      $Exec->Finish();
    }

  //$Args['Exec'     ]=$this->Create_Exec();
  //$Args['Objects'  ]=$this->ExtractAssets('Cpp/Obj');
  //$Args['Libs'     ]=$this->ExtractAssetsR('Cpp/Lib');
  //$Args['DllAsset' ]=$this->CreateAsset('Bin/Dll', ['Path'=>$Compiler->GetDllFile    ($Name)]);
  //$Args['LibAsset' ]=$this->CreateAsset('Bin/Lib', ['Path'=>$Compiler->GetDllLibFile ($Name)]);
    Final Function BuildDll(Array $Args)
    {
      $Exec      =$Args['Exec'      ];
      $Objects   =$Args['Objects'   ];
      $Libs      =$Args['Libs'      ];
      $Using     =$Args['Using'     ];
      $DllAsset  =$Args['DllAsset'  ];
      $LibAsset  =$Args['LibAsset'  ]??false;
      $ResAsset  =$Args['ResAsset'  ]??[];
      $Resources =$Args['Resources' ]??[];
      $Manifests =$Args['Manifests' ]??[];
      
      $Libs=Static::AgregateLibs($Libs); $Args['Libs']=$Libs;
      
      ForEach($Objects As $Item) $DllAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));
      ForEach($Libs    As $Item) $DllAsset->AddFileDepends($Item->GetFileDependsR('Bin/Dll'));
      if($LibAsset)              $LibAsset->AddFileDepends($DllAsset);
      ForEach($Using   As $Item) $Item->UseForDll($DllAsset);
      
      $this->PrepareExec($Exec);
      
      $Exec->Descr('Build ',$DllAsset->GetLocalPathNick());
      $Exec->CheckFiles($Objects   );
      $Exec->CheckFiles($Libs      );
      $Exec->CheckFiles($Using     );
      $Exec->CheckFiles($ResAsset  );
      $Exec->CheckFiles($Resources );
      $Exec->CheckFiles($Manifests );
      $Exec->MkDir($DllAsset);
      if($LibAsset)
        $Exec->MkDir($LibAsset);
      
      $this->_BuildDll($Args);
      
      $Exec->CheckResultFile($DllAsset);
      if($LibAsset)
        $Exec->CheckResultFile($LibAsset);
      
      $Exec->SaveCallTo();
      $Exec->Finish();
    }

  //$Args['Exec'     ]=$this->Create_Exec();
  //$Args['Objects'  ]=$this->ExtractAssets('Cpp/Obj');
  //$Args['Libs'     ]=$this->ExtractAssetsR('Cpp/Lib');
  //$Args['LibAsset' ]=$this->CreateAsset('Bin/Lib', ['Path'=>$Compiler->GetLibFile ($Name)]);
    Final Function BuildLib(Array $Args)
    {
      $Exec     =$Args['Exec'     ];
      $Objects  =$Args['Objects'  ];
      $Libs     =$Args['Libs'     ];
      $Using    =$Args['Using'    ];
      $LibAsset =$Args['LibAsset' ];
      
    //ForEach($Objects As $Item) $LibAsset->AddFileDepends($Item); //TODO: Add 'Bin/Dll' and 'Cpp/Lib'
      ForEach($Libs    As $Item) $LibAsset->AddFileDepends($Item); //'Bin/Dll'
      ForEach($Using   As $Item) $Item->UseForLib($LibAsset);
      
      $this->PrepareExec($Exec);
      
      $Exec->Descr('MakeLib ',$LibAsset->GetLocalPathNick());
      
      $Exec->CheckFiles($Objects );
    //$Exec->CheckFiles($Libs    );
      $Exec->MkDir($LibAsset);
 
      $this->_BuildLib($Args);
      $Exec->CheckResultFile($LibAsset);
      $Exec->SaveCallTo();
      $Exec->Finish();
    }

    Function CreateParams() { return $this->Create_Object('/Builder/Task/Params'); }
  //****************************************************************
  // Debug
    
    Protected Function _Debug_Info(Array &$Res)
    {
      Parent::_Debug_Info($Res);
      UnSet($Res['Manager' ]);
    }
      
    Function _ToDebugInfo() { return $this->CMake_GetGenerator(); }
  
  //****************************************************************
  }
?>