<?
  $Loader->Parent_Class('/Builder/Asset/Cpp/Compile');

  class C_Builder_Asset_Cpp_MakeLib extends C_Builder_Asset_Cpp_Compile
  {
    Static Function Make($Outer, $Compiler, $Param)
    {
      // $Mode==0 -- No compile, only source
      // $Mode==1 -- Compile but only object files
      // $Mode==2 -- Compile but one liberary file
      // $Mode==3 -- Compile and generate DLL if avalible
      $Mode=$Outer->IsStatic()? 2:3; // TODO: Customization

      $bDebug=$Outer->IsDebug();
      $DebugPostfix =$Param['DebugPostfix' ]??True;
      $_d=$bDebug? (Is_String($DebugPostfix)? $DebugPostfix:'_d'):'';
      
      $OutPath=$Param['OutPath'];
      
      $DLL=IsSet($Param['DLL'])? $Param['DLL']:''; // TODOL "??" ?
      $Def=IsSet($Param['Def'])? $Param['Def']:[];
      if(!Is_Array($Def))
        $Def=[$Def];
      $IsDll = $Mode>=3 &&($DLL!==''||Count($Def)>0);
      $IsLib = $Mode>=2 && !$IsDll;
      $IsObj = $Mode>=1;
      $LibName=Static::_GetName($Param, $Outer);
      
      $DefineAssets=[];
      
      if($DLL!=='')
      {
        if(Is_String($DLL))
          $DLL=[$DLL=>'Extern'];
      //if(IsSet($DLL['>Proxy']))
      //{
      //  $DLL_Proxy=$DLL['>Proxy'];
      //  UnSet($DLL['>Proxy']);
      //}
      //else
      //  $DLL_Proxy=[];
        $DLL_Export =[];
        $DLL_Import =[];
        $DLL_Zero   =[];
        ForEach($DLL As $DLLi=>$DllType)
        {
          if(Is_Integer($DLLi))
          {
            $DLLi    =$DllType;
            $DllType ='Extern';
          }
          switch($DllType)
          {
          case 'Extern':
            $DLL_Export [$DLLi]=$Compiler->DefineDLLExport();
            $DLL_Import [$DLLi]=$Compiler->DefineDLLImport();
            $DLL_Zero   [$DLLi]='';
            break;
          default:
            // TODO: static 
            $DefTypes=[                        // Zero  ,TODO:   
              //                  Export ,Import ,Lib   ,Include 
            //'Define'        => [true   ,false  ,false ,false   ], //< TODO: Deprecated
            //'Liberary'      => [false  ,true   ,true  ,true    ],
              'IsStatic'      => [false  ,false  ,true  ,true    ],
              'IsDll'         => [true   ,true   ,false ,false   ],
              'IsBuild'       => [true   ,false  ,true  ,false   ],
              'IsBuildStatic' => [false  ,false  ,true  ,false   ],
              'IsBuildDll'    => [true   ,false  ,false ,false   ],
              'IsUseDll'      => [false  ,true   ,false ,false   ],
              'IsHeader'      => [false  ,true   ,false ,true    ],
            ];
            if(IsSet($DefTypes[$DllType]))
            {
              $DT=$DefTypes[$DllType];
              if($DT[0]) $DLL_Export [$DLLi]='';
              if($DT[1]) $DLL_Import [$DLLi]='';
              if($DT[2]) $DLL_Zero   [$DLLi]='';
            }
            else
              $this->Fatal('Unknown DllType ',$DllType);
          }
        }
        $DefineAssets+=$Outer->CreateAssets('Cpp/Define', $IsDll? $DLL_Export:$DLL_Zero);
      }
      
      if($IsObj)
      {
        $_Param=$Param;
        $_Param['DepUsing']=!$IsDll && !$IsLib;
        Static::Compile($Outer, $Compiler, $_Param);
      }
      
      ForEach($DefineAssets As $DefineAsset)
        $DefineAsset->RemoveFromOuter();
      
      if($IsDll || $IsLib)
      {
        $PathLibAsset=$Outer->CreateAsset('Cpp/LibPath', $OutPath.'Lib');
        
        if($IsDll)
        {
          $PathDllAsset =$Outer->CreateAsset('Bin/Path', $OutPath.'Bin');
          $DefAssets=[];
          ForEach($Def As $DefItem)
            $DefAssets[]  =$Outer->CreateAsset('Cpp/Def', $DefItem);
          
          $DllAsset=$Outer->CreateAsset   ('Bin/Dll'   ,['Path'=>$Compiler->GetDllFile    ($LibName.$_d), '>Create'=>1]);
          $Compiler->BuildDll([
            'Outer'     =>$Outer,
            'Name'      =>$LibName,
            'Exec'      =>$DllAsset->CreateExec(['CachePath'=>$OutPath.'Task/Dll/'.$LibName, 'Performance'=>'Build']),
            'Objects'   =>$Outer->ExtractAssets ('Cpp/Obj'   ),
            'Libs'      =>$Outer->GetAssets     ('Cpp/Lib'   ),
            'Using'     =>$Outer->GetAssets     ('Cpp/Using' ),
            'DllAsset'  =>$DllAsset,
            'LibAsset'  =>$Outer->CreateAsset   ('Cpp/Lib'   ,['Path'=>$Compiler->GetDllLibFile ($LibName.$_d), '>Create'=>1,
              '>FileDepends'=>$Param['>FileDepends']??[],
            ]),
            'ResAsset'  =>$Outer->ExtractAssets ('Cpp/Res'       ),
            'DefAsset'  =>$Outer->ExtractAssets ('Cpp/Def'       ),
            'Resources' =>$Outer->ExtractAssets ('Cpp/Resources' ),
            'Manifests' =>$Outer->ExtractAssets ('Cpp/Manifest'  ),
          ]);
          $Outer->CreateAsset('Cpp/Define', $DLL_Import);
  
          $PathDllAsset->RemoveFromOuter();
        //ForEach($DefAssets As $DefAsset) //<Removed by Compiler
        //  $DefAsset->RemoveFromOuter();
        //TODO: $DllAsset->RemoveFromOuter();
        }
        if($IsLib)
        {
          $LibAsset= $Outer->CreateAsset   ('Cpp/Lib'  ,[
            'Path'     =>$Compiler->GetLibFile ($LibName.$_d),
            '>Create'=>1,
          ]);
          $Compiler->BuildLib([
            'Outer'    =>$Outer,
            'Exec'     =>$LibAsset->CreateExec(['CachePath'=>$OutPath.'Task/Lib/'.$LibName, 'Performance'=>'LinkLib']),
            'Objects'  =>$Outer->ExtractAssets ('Cpp/Obj'   ),
            'Using'    =>$Outer->GetAssets     ('Cpp/Using' ),
            'Libs'     =>$Outer->GetAssets     ('Cpp/Lib'   ),
            'LibAsset' =>$LibAsset,
          ]);
        }
        $PathLibAsset->RemoveFromOuter();
      }
    //$Outer->CreateAsset('CPP/Define', ['TestBadObject']); // Check generate error
    }
  };
?>